drop table if exists cdmpv532_daily.drug_era;;

CREATE TABLE cdmpv532_daily.DRUG_ERA
    (
     drug_era_id					INTEGER	  GENERATED BY DEFAULT AS IDENTITY   NOT NULL ,
     person_id				        INTEGER   NOT NULL ,
     drug_concept_id				INTEGER   NOT NULL ,
     drug_era_start_date			DATE      NOT NULL ,
     drug_era_end_date				DATE 	  NOT NULL ,
     drug_exposure_count			INTEGER			NULL,
	 gap_days						INTEGER			NULL
	 )
;

drop table if exists itfcdmpv532_daily.ctePreDrugTarget ;

create table itfcdmpv532_daily.ctePreDrugTarget as
SELECT
		d.drug_exposure_id
		, d.person_id
		, c.concept_id AS ingredient_concept_id
		, d.drug_exposure_start_date AS drug_exposure_start_date
		, d.days_supply AS days_supply
		, COALESCE(
			  NULLIF(drug_exposure_end_date, NULL) ---If drug_exposure_end_date != NULL, return drug_exposure_end_date, otherwise go to next case
			, NULLIF(drug_exposure_start_date + (INTERVAL '1 day' * days_supply), drug_exposure_start_date) ---If days_supply != NULL or 0, return drug_exposure_start_date + days_supply, otherwise go to next case
			, drug_exposure_start_date + INTERVAL '1 day' ---Add 1 day to the drug_exposure_start_date since there is no end_date or INTERVAL for the days_supply
		) AS drug_exposure_end_date
	FROM cdmpv532_daily.drug_exposure d
	JOIN cdmpv532_daily.concept_ancestor ca ON ca.descendant_concept_id = d.drug_concept_id
	JOIN cdmpv532_daily.concept c ON ca.ancestor_concept_id = c.concept_id
	WHERE c.vocabulary_id in ('RxNorm', 'RxNorm Extension') ---8 selects RxNorm from the vocabulary_id, RxNorm extension
	AND c.concept_class_id = 'Ingredient'
	/* Depending on the needs of your data, you can put more filters on to your code. We assign 0 to unmapped drug_concept_id's, and we found data where days_supply was negative.
	 * We don't want different drugs put in the same era, so the code below shows how we filtered them out.
 	 * We also don't want negative days_supply, because that will pull our end_date before the start_date due to our second parameter in the COALESCE function.
 	 * For now, we are filtering those out as well, but this is a data quality issue that we are trying to solve.
 	 */
	---AND d.drug_concept_id != 0
	---AND d.days_supply >= 0
;

drop table if exists itfcdmpv532_daily.cteSubExposureEndDates;

create table itfcdmpv532_daily.cteSubExposureEndDates as
SELECT
		person_id
		, ingredient_concept_id
		, event_date AS end_date
	FROM
	(
		SELECT
			person_id
			, ingredient_concept_id
			, event_date
			, event_type
			, MAX(start_ordinal) OVER (PARTITION BY person_id, ingredient_concept_id ORDER BY event_date, event_type ROWS unbounded preceding) AS start_ordinal -- this pulls the current START down from the prior rows so that the NULLs from the END DATES will contain a value we can compare with
			, ROW_NUMBER() OVER (PARTITION BY person_id, ingredient_concept_id ORDER BY event_date, event_type) AS overall_ord -- this re-numbers the inner UNION so all rows are numbered ordered by the event date
		FROM (
			-- select the start dates, assigning a row number to each
			SELECT
				person_id
				, ingredient_concept_id
				, drug_exposure_start_date AS event_date
				, -1 AS event_type
				, ROW_NUMBER() OVER (PARTITION BY person_id, ingredient_concept_id ORDER BY drug_exposure_start_date) AS start_ordinal
			FROM itfcdmpv532_daily.ctePreDrugTarget

			UNION ALL

			SELECT
				person_id
				, ingredient_concept_id
				, drug_exposure_end_date
				, 1 AS event_type
				, NULL
			FROM itfcdmpv532_daily.ctePreDrugTarget
		) RAWDATA
	) e
	WHERE (2 * e.start_ordinal) - e.overall_ord = 0 ;
---------

drop table if exists  itfcdmpv532_daily.cteDrugExposureEnds ;
create table itfcdmpv532_daily.cteDrugExposureEnds as
SELECT
	       dt.person_id
	       , dt.ingredient_concept_id
	       , dt.drug_exposure_start_date
	       , MIN(e.end_date) AS drug_sub_exposure_end_date
	FROM itfcdmpv532_daily.ctePreDrugTarget dt
	JOIN itfcdmpv532_daily.cteSubExposureEndDates e ON dt.person_id = e.person_id AND dt.ingredient_concept_id = e.ingredient_concept_id AND e.end_date >= dt.drug_exposure_start_date
	GROUP BY
      	      dt.drug_exposure_id
      	      , dt.person_id
	      , dt.ingredient_concept_id
	      , dt.drug_exposure_start_date
 ;;

---------------
drop table if exists   itfcdmpv532_daily.cteSubExposures  ;

create table itfcdmpv532_daily.cteSubExposures as
SELECT
		ROW_NUMBER() OVER (PARTITION BY person_id, ingredient_concept_id, drug_sub_exposure_end_date) row_number
		, person_id
		,  ingredient_concept_id drug_concept_id
		, MIN(drug_exposure_start_date) AS drug_sub_exposure_start_date
		, drug_sub_exposure_end_date
		, COUNT(*) AS drug_exposure_count
	FROM itfcdmpv532_daily.cteDrugExposureEnds
	GROUP BY person_id, ingredient_concept_id, drug_sub_exposure_end_date
	ORDER BY person_id, ingredient_concept_id
 ;

drop table if exists  itfcdmpv532_daily.cteFinalTarget ;
create table itfcdmpv532_daily.cteFinalTarget as
	SELECT
		row_number
		, person_id
		, drug_concept_id
		, drug_sub_exposure_start_date
		, drug_sub_exposure_end_date
		, drug_exposure_count
		, drug_sub_exposure_end_date - drug_sub_exposure_start_date AS days_exposed
	FROM itfcdmpv532_daily.cteSubExposures
;;

drop table if exists   itfcdmpv532_daily.cteEndDates ;

create table itfcdmpv532_daily.cteEndDates as
SELECT
		person_id
		, ingredient_concept_id
		, event_date - INTERVAL '30 days' AS end_date -- unpad the end date
	FROM
	(
		SELECT
			person_id
			, ingredient_concept_id
			, event_date
			, event_type
			, MAX(start_ordinal) OVER (PARTITION BY person_id, ingredient_concept_id ORDER BY event_date, event_type ROWS UNBOUNDED PRECEDING) AS start_ordinal -- this pulls the current START down from the prior rows so that the NULLs from the END DATES will contain a value we can compare with
			, ROW_NUMBER() OVER (PARTITION BY person_id, ingredient_concept_id ORDER BY event_date, event_type) AS overall_ord -- this re-numbers the inner UNION so all rows are numbered ordered by the event date
		FROM (
			-- select the start dates, assigning a row number to each
			SELECT
				person_id
				, drug_concept_id ingredient_concept_id
				, drug_sub_exposure_start_date AS event_date
				, -1 AS event_type
				, ROW_NUMBER() OVER (PARTITION BY person_id, drug_concept_id ORDER BY drug_sub_exposure_start_date) AS start_ordinal
			FROM itfcdmpv532_daily.cteFinalTarget

			UNION ALL

			-- pad the end dates by 30 to allow a grace period for overlapping ranges.
			SELECT
				person_id
				, drug_concept_id ingredient_concept_id
				, drug_sub_exposure_end_date + INTERVAL '30 days'
				, 1 AS event_type
				, NULL
			FROM itfcdmpv532_daily.cteFinalTarget
		) RAWDATA
	) e
	WHERE (2 * e.start_ordinal) - e.overall_ord = 0
 ;

drop table if exists  itfcdmpv532_daily.cteDrugEraEnds ;
create table itfcdmpv532_daily.cteDrugEraEnds as
SELECT
	ft.person_id
	, ft.drug_concept_id ingredient_concept_id
	, ft.drug_sub_exposure_start_date
	, MIN(e.end_date) AS era_end_date
	, ft.drug_exposure_count
	, ft.days_exposed
FROM itfcdmpv532_daily.cteFinalTarget ft
JOIN itfcdmpv532_daily.cteEndDates e ON ft.person_id = e.person_id AND ft.drug_concept_id = e.ingredient_concept_id AND e.end_date >= ft.drug_sub_exposure_start_date
GROUP BY
      	ft.person_id
	, ft.drug_concept_id
	, ft.drug_sub_exposure_start_date
	, ft.drug_exposure_count
	, ft.days_exposed
;



INSERT INTO cdmpv532_daily.drug_era(person_id, drug_concept_id, drug_era_start_date, drug_era_end_date, drug_exposure_count, gap_days)
select person_id
	 , ingredient_concept_id drug_concept_id
	 , MIN(drug_sub_exposure_start_date) AS drug_era_start_date
	 , era_end_date drug_era_end_date
	 , SUM(drug_exposure_count) AS drug_exposure_count
	 , EXTRACT(EPOCH FROM era_end_date - MIN(drug_sub_exposure_start_date) - SUM(days_exposed)) / 86400 AS gap_days
FROM itfcdmpv532_daily. cteDrugEraEnds
GROUP BY person_id, ingredient_concept_id, era_end_date
ORDER BY person_id, ingredient_concept_id
;;



/*
---This is a common test to make sure you have the same number of exposures going in as contribute to the count at the end.
---Make sure the JOIN and AND statements are the same as above so that your counts actually represent what you should be getting.
SELECT
	(SELECT COUNT(*) FROM .drug_exposure d JOIN cdmpv532_daily.concept_ancestor ca ON ca.descendant_concept_id = d.drug_concept_id
		JOIN cdmpv532_daily.concept c ON ca.ancestor_concept_id = c.concept_id
		WHERE c.vocabulary_id = 8 ---8 selects RxNorm from the vocabulary_id
		AND c.concept_class = 'Ingredient'
		AND d.drug_concept_id != 0 ---Our unmapped drug_concept_id's are set to 0, so we don't want different drugs wrapped up in the same era
		AND d.days_supply >= 0) AS count
	, (SELECT SUM(drug_exposure_count) FROM .drug_era) AS sum
*/
ALTER TABLE cdmpv532_daily.drug_era ADD CONSTRAINT xpk_drug_era PRIMARY KEY ( drug_era_id ) ;;
--alter table cdmpv532_daily.drug_era alter column person_id set not null;
--alter table cdmpv532_daily.drug_era alter column drug_concept_id set not null;
--alter table cdmpv532_daily.drug_era alter column drug_era_start_date set not null;
--alter table cdmpv532_daily.drug_era alter column drug_era_end_date set not null;
CREATE INDEX idx_drug_era_person_id  ON cdmpv532_daily.drug_era  (person_id ASC);;
CLUSTER cdmpv532_daily.drug_era  USING idx_drug_era_person_id ;;
CREATE INDEX idx_drug_era_concept_id ON cdmpv532_daily.drug_era (drug_concept_id ASC);;